/* 
mzCanvas a TypeScript-based library for manipulating canvas element and 2D graphics in the browser.
Version: 1.0.2
Author: Miriam Zusin     
Contact: miriam.zusin@gmail.com
Documentation: https://github.com/mzusin/mz-canvas
Licensed GPLv3 for open source use, or Commercial License for commercial use - https://github.com/mzusin/index/blob/main/LICENSE.md                 
*/
var h=(e,t)=>{for(let i of t){let n=i[1];if(n===void 0)continue;let l=i[0];e.setAttribute(l,n.toString())}},d=(e,t)=>{for(let i of e){let n=i[1];if(n===void 0)continue;let l=i[0];t[l]=n}},g=e=>{let t=document.createElement("canvas"),i=window.devicePixelRatio;t.width=e.width*i,t.height=e.height*i,h(t,[["id",e.id],["class",e.classes],["style",e.style],["title",e.title],["tabindex",e.tabindex],["role",e.role],["aria-label",e.ariaLabel]]),e.fallback&&(t.textContent=e.fallback);let n=typeof t.getContext=="function"?t.getContext("2d"):null;return n==null||n.scale(i,i),t.style.width=`${e.width}px`,t.style.height=`${e.height}px`,{ctx:n,$canvas:t}},s=(e,t)=>{d([["lineWidth",e.lineWidth],["strokeStyle",e.strokeStyle],["lineCap",e.lineCap],["lineJoin",e.lineJoin],["miterLimit",e.miterLimit],["lineDashOffset",e.lineDashOffset]],t),e.lineDashSegments&&t.setLineDash(e.lineDashSegments)},f=(e,t)=>{e.fillStyle!==void 0&&(t.fillStyle=e.fillStyle),d([["shadowOffsetX",e.shadowOffsetX],["shadowOffsetY",e.shadowOffsetY],["shadowBlur",e.shadowBlur],["shadowColor",e.shadowColor]],t)};var u=(e,t)=>{let{x1:i,y1:n,x2:l,y2:a}=e;t.save(),t.beginPath(),t.moveTo(i,n),t.lineTo(l,a),e.fillStyle&&(f(e,t),t.fill()),e.strokeStyle&&(s(e,t),t.stroke()),t.restore()},C=(e,t)=>{let{x1:i,y1:n,x2:l,y2:a}=e,o=new Path2D;return o.moveTo(i,n),o.lineTo(l,a),t&&(t.save(),e.fillStyle&&(f(e,t),t.fill(o)),e.strokeStyle&&(s(e,t),t.stroke(o)),t.restore()),o},v=(e,t)=>{let{x:i,y:n,w:l,h:a}=e;if(e.clear){t.clearRect(i,n,l,a);return}if(e.radii){t.save(),f(e,t),s(e,t),t.beginPath(),t.roundRect(i,n,l,a,e.radii),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore();return}t.save(),e.fillStyle&&(f(e,t),t.fillRect(i,n,l,a)),e.strokeStyle&&(s(e,t),t.strokeRect(i,n,l,a)),t.restore()},R=(e,t)=>{let{x:i,y:n,w:l,h:a}=e,o=new Path2D;return e.radii?o.roundRect(i,n,l,a,e.radii):o.rect(i,n,l,a),t&&(t.save(),e.fillStyle&&(f(e,t),t.fill(o)),e.strokeStyle&&(s(e,t),t.stroke(o)),t.restore()),o},k=(e,t)=>{let{points:i}=e;t.save(),f(e,t),s(e,t),t.beginPath();for(let n=0;n<i.length;n++){let l=i[n];n===0?t.moveTo(l[0],l[1]):t.lineTo(l[0],l[1])}e.closed&&t.closePath(),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore()},S=(e,t)=>{let{points:i}=e,n=new Path2D;for(let l=0;l<i.length;l++){let a=i[l];l===0?n.moveTo(a[0],a[1]):n.lineTo(a[0],a[1])}return e.closed&&n.closePath(),t&&(t.save(),e.fillStyle&&(f(e,t),t.fill(n)),e.strokeStyle&&(s(e,t),t.stroke(n)),t.restore()),n},m=(e,t)=>{let{cx:i,cy:n,r:l}=e,a=e.startAngleRad===void 0?0:e.startAngleRad,o=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad;t.save(),t.beginPath(),f(e,t),s(e,t),t.arc(i,n,l,a,o,e.counterclockwise),e.fillStyle&&t.fill(),e.strokeStyle&&(s(e,t),t.stroke()),t.restore()},c=(e,t)=>{let{cx:i,cy:n,r:l}=e,a=e.startAngleRad===void 0?0:e.startAngleRad,o=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad,r=new Path2D;return r.arc(i,n,l,a,o,e.counterclockwise),t&&(t.save(),e.fillStyle&&(f(e,t),t.fill(r)),e.strokeStyle&&(s(e,t),t.stroke(r)),t.restore()),r};export{g as canvas,m as circle,c as circlePath,f as fill,u as line,C as linePath,k as polynomial,S as polynomialPath,v as rect,R as rectPath,d as setContextProps,s as stroke};
//# sourceMappingURL=mz-canvas.esm.js.map
