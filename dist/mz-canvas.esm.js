/* 
mzCanvas a TypeScript-based library for manipulating canvas element and 2D graphics in the browser.
Version: 1.0.4
Author: Miriam Zusin     
Contact: miriam.zusin@gmail.com
Documentation: https://github.com/mzusin/mz-canvas
Licensed GPLv3 for open source use, or Commercial License for commercial use - https://github.com/mzusin/index/blob/main/LICENSE.md                 
*/
var h=e=>!isNaN(parseFloat(e))&&isFinite(e);var f=(e,t)=>{for(let a of t){let r=a[1];if(r===void 0)continue;let n=a[0];e.setAttribute(n,r.toString())}},m=(e,t)=>{for(let a of e){let r=a[1];if(r===void 0)continue;let n=a[0];t[n]=r}},c=e=>{let t=document.createElement("canvas"),a=window.devicePixelRatio;h(e.width)&&h(e.height)&&(t.width=e.width*a,t.height=e.height*a),f(t,[["id",e.id],["class",e.classes],["style",e.style],["title",e.title],["tabindex",e.tabindex],["role",e.role],["aria-label",e.ariaLabel]]),e.fallback&&(t.textContent=e.fallback);let n=typeof t.getContext=="function"?t.getContext("2d"):null;return n==null||n.scale(a,a),t.style.width=h(e.width)?`${e.width}px`:e.width.toString(),t.style.height=h(e.height)?`${e.height}px`:e.height.toString(),{ctx:n,$canvas:t}},o=(e,t)=>{m([["lineWidth",e.lineWidth],["strokeStyle",e.strokeStyle],["lineCap",e.lineCap],["lineJoin",e.lineJoin],["miterLimit",e.miterLimit],["lineDashOffset",e.lineDashOffset]],t),e.lineDashSegments&&t.setLineDash(e.lineDashSegments)},i=(e,t)=>{e.fillStyle!==void 0&&(t.fillStyle=e.fillStyle),m([["shadowOffsetX",e.shadowOffsetX],["shadowOffsetY",e.shadowOffsetY],["shadowBlur",e.shadowBlur],["shadowColor",e.shadowColor]],t)};var S=(e,t)=>{let{x1:a,y1:r,x2:n,y2:l}=e;t.save(),t.beginPath(),t.moveTo(a,r),t.lineTo(n,l),e.strokeStyle&&(o(e,t),t.stroke()),t.restore()},x=(e,t)=>{let{x1:a,y1:r,x2:n,y2:l}=e,s=new Path2D;return s.moveTo(a,r),s.lineTo(n,l),t&&(t.save(),e.strokeStyle&&(o(e,t),t.stroke(s)),t.restore()),s},C=(e,t)=>{let{x:a,y:r,w:n,h:l}=e;if(e.clear){t.clearRect(a,r,n,l);return}if(e.radii){t.save(),i(e,t),o(e,t),t.beginPath(),t.roundRect(a,r,n,l,e.radii),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore();return}t.save(),e.fillStyle&&(i(e,t),t.fillRect(a,r,n,l)),e.strokeStyle&&(o(e,t),t.strokeRect(a,r,n,l)),t.restore()},w=(e,t)=>{let{x:a,y:r,w:n,h:l}=e,s=new Path2D;return e.radii?s.roundRect(a,r,n,l,e.radii):s.rect(a,r,n,l),t&&(t.save(),e.fillStyle&&(i(e,t),t.fill(s)),e.strokeStyle&&(o(e,t),t.stroke(s)),t.restore()),s},R=(e,t)=>{let{points:a}=e;t.save(),i(e,t),o(e,t),t.beginPath();for(let r=0;r<a.length;r++){let n=a[r];r===0?t.moveTo(n[0],n[1]):t.lineTo(n[0],n[1])}e.closed&&t.closePath(),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore()},y=(e,t)=>{let{points:a}=e,r=new Path2D;for(let n=0;n<a.length;n++){let l=a[n];n===0?r.moveTo(l[0],l[1]):r.lineTo(l[0],l[1])}return e.closed&&r.closePath(),t&&(t.save(),e.fillStyle&&(i(e,t),t.fill(r)),e.strokeStyle&&(o(e,t),t.stroke(r)),t.restore()),r},b=(e,t)=>{let{cx:a,cy:r,r:n}=e,l=e.startAngleRad===void 0?0:e.startAngleRad,s=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad;t.save(),t.beginPath(),i(e,t),o(e,t),t.arc(a,r,n,l,s,e.counterclockwise),e.fillStyle&&t.fill(),e.strokeStyle&&(o(e,t),t.stroke()),t.restore()},P=(e,t)=>{let{cx:a,cy:r,r:n}=e,l=e.startAngleRad===void 0?0:e.startAngleRad,s=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad,u=new Path2D;return u.arc(a,r,n,l,s,e.counterclockwise),t&&(t.save(),e.fillStyle&&(i(e,t),t.fill(u)),e.strokeStyle&&(o(e,t),t.stroke(u)),t.restore()),u};export{c as canvas,b as circle,P as circlePath,i as fill,S as line,x as linePath,R as polynomial,y as polynomialPath,C as rect,w as rectPath,m as setContextProps,o as stroke};
//# sourceMappingURL=mz-canvas.esm.js.map
