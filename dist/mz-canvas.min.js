/* 
mzCanvas a TypeScript-based library for manipulating canvas element and 2D graphics in the browser.
Version: 1.0.12
Author: Miriam Zusin     
Contact: miriam.zusin@gmail.com
Documentation: https://github.com/mzusin/mz-canvas
Licensed GPLv3 for open source use, or Commercial License for commercial use - https://github.com/mzusin/index/blob/main/LICENSE.md                 
*/
(()=>{var S=Object.defineProperty;var c=Object.getOwnPropertySymbols;var R=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var M=(e,t,n)=>t in e?S(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,h=(e,t)=>{for(var n in t||(t={}))R.call(t,n)&&M(e,n,t[n]);if(c)for(var n of c(t))x.call(t,n)&&M(e,n,t[n]);return e};var w=(e,t)=>{for(var n in t)S(e,n,{get:t[n],enumerable:!0})};var d={};w(d,{canvas:()=>y,fill:()=>o,setCanvasSize:()=>C,setContextProps:()=>f,stroke:()=>s});var m=e=>!isNaN(parseFloat(e))&&isFinite(e);var b=(e,t)=>{for(let n of t){let r=n[1];if(r===void 0)continue;let a=n[0];e.setAttribute(a,r.toString())}},f=(e,t)=>{for(let n of e){let r=n[1];if(r===void 0)continue;let a=n[0];t[a]=r}},C=(e,t,n)=>{let r=m(n.width)&&m(n.height),a=r?n.width:0,l=r?n.height:0;if(!r){let u=!!e.parentNode;u||(e.style.width=n.width.toString(),e.style.height=n.height.toString(),document.body.append(e));let v=e.getBoundingClientRect();a=v.width,l=v.height,u||e.remove()}let i;n.restoreImageDataOnResize&&(i=t==null?void 0:t.getImageData(0,0,e.width,e.height)),e.width=a,e.height=l,n.restoreImageDataOnResize&&t&&i&&t.putImageData(i,0,0)},y=e=>{let t=document.createElement("canvas");b(t,[["id",e.id],["class",e.classes],["style",e.style],["title",e.title],["tabindex",e.tabindex],["role",e.role],["aria-label",e.ariaLabel]]),e.fallback&&(t.textContent=e.fallback);let n=typeof t.getContext=="function"?t.getContext("2d",e.contextAttributes):null;return C(t,n,e),{ctx:n,$canvas:t}},s=(e,t)=>{f([["lineWidth",e.lineWidth],["strokeStyle",e.strokeStyle],["lineCap",e.lineCap],["lineJoin",e.lineJoin],["miterLimit",e.miterLimit],["lineDashOffset",e.lineDashOffset]],t),e.lineDashSegments&&t.setLineDash(e.lineDashSegments)},o=(e,t)=>{e.fillStyle!==void 0&&(t.fillStyle=e.fillStyle),f([["shadowOffsetX",e.shadowOffsetX],["shadowOffsetY",e.shadowOffsetY],["shadowBlur",e.shadowBlur],["shadowColor",e.shadowColor]],t)};var g={};w(g,{circle:()=>k,circlePath:()=>z,line:()=>P,linePath:()=>D,polynomial:()=>I,polynomialPath:()=>H,rect:()=>T,rectPath:()=>A});var P=(e,t)=>{let{x1:n,y1:r,x2:a,y2:l}=e;t.save(),t.beginPath(),t.moveTo(n,r),t.lineTo(a,l),e.strokeStyle&&(s(e,t),t.stroke()),t.restore()},D=(e,t)=>{let{x1:n,y1:r,x2:a,y2:l}=e,i=new Path2D;return i.moveTo(n,r),i.lineTo(a,l),t&&(t.save(),e.strokeStyle&&(s(e,t),t.stroke(i)),t.restore()),i},T=(e,t)=>{let{x:n,y:r,w:a,h:l}=e;if(e.clear){t.clearRect(n,r,a,l);return}if(e.radii){t.save(),o(e,t),s(e,t),t.beginPath(),t.roundRect(n,r,a,l,e.radii),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore();return}t.save(),e.fillStyle&&(o(e,t),t.fillRect(n,r,a,l)),e.strokeStyle&&(s(e,t),t.strokeRect(n,r,a,l)),t.restore()},A=(e,t)=>{let{x:n,y:r,w:a,h:l}=e,i=new Path2D;return e.radii?i.roundRect(n,r,a,l,e.radii):i.rect(n,r,a,l),t&&(t.save(),e.fillStyle&&(o(e,t),t.fill(i)),e.strokeStyle&&(s(e,t),t.stroke(i)),t.restore()),i},I=(e,t)=>{let{points:n}=e;t.save(),o(e,t),s(e,t),t.beginPath();for(let r=0;r<n.length;r++){let a=n[r];r===0?t.moveTo(a[0],a[1]):t.lineTo(a[0],a[1])}e.closed&&t.closePath(),e.fillStyle&&t.fill(),e.strokeStyle&&t.stroke(),t.restore()},H=(e,t)=>{let{points:n}=e,r=new Path2D;for(let a=0;a<n.length;a++){let l=n[a];a===0?r.moveTo(l[0],l[1]):r.lineTo(l[0],l[1])}return e.closed&&r.closePath(),t&&(t.save(),e.fillStyle&&(o(e,t),t.fill(r)),e.strokeStyle&&(s(e,t),t.stroke(r)),t.restore()),r},k=(e,t)=>{let{cx:n,cy:r,r:a}=e,l=e.startAngleRad===void 0?0:e.startAngleRad,i=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad;t.save(),t.beginPath(),o(e,t),s(e,t),t.arc(n,r,a,l,i,e.counterclockwise),e.fillStyle&&t.fill(),e.strokeStyle&&(s(e,t),t.stroke()),t.restore()},z=(e,t)=>{let{cx:n,cy:r,r:a}=e,l=e.startAngleRad===void 0?0:e.startAngleRad,i=e.endAngleRad===void 0?2*Math.PI:e.endAngleRad,u=new Path2D;return u.arc(n,r,a,l,i,e.counterclockwise),t&&(t.save(),e.fillStyle&&(o(e,t),t.fill(u)),e.strokeStyle&&(s(e,t),t.stroke(u)),t.restore()),u};var E=h(h({},d),g);window.mzCanvas=window.mzCanvas||E;})();
//# sourceMappingURL=mz-canvas.min.js.map
