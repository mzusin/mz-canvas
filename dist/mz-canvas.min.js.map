{
  "version": 3,
  "sources": ["../src/core/canvas.ts", "../src/core/shapes/primitive-shapes.ts", "../src/index.ts"],
  "sourcesContent": ["import { ICanvas, IFillProps, IStrokeProps } from '../interfaces';\n\nconst setAttributes = ($canvas: HTMLCanvasElement, attributes: [string, string|number|undefined][]) => {\n    for(const attr of attributes){\n\n        const value = attr[1];\n        if(value === undefined) continue;\n\n        const key = attr[0];\n        $canvas.setAttribute(key, value.toString());\n    }\n};\n\nexport const setContextProps = (props: [string, string|number|undefined][], ctx: CanvasRenderingContext2D) => {\n    for(const prop of props){\n\n        const value = prop[1];\n        if(value === undefined) continue;\n\n        const key = prop[0];\n        ctx[key] = value;\n    }\n};\n\nexport const canvas = (props: ICanvas) => {\n\n    const $canvas: HTMLCanvasElement = document.createElement('canvas');\n\n    setAttributes($canvas, [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n        ['title', props.title],\n        ['tabindex', props.tabindex],\n        ['role', props.role],\n        ['aria-label', props.ariaLabel],\n    ]);\n\n    // Used to make the canvas accessible by providing fallback text\n    // to be displayed when the media doesn't load\n    // or the user is unable to experience it as intended\n    if(props.fallback){\n        $canvas.textContent = props.fallback;\n    }\n\n    const ctx =\n        typeof $canvas.getContext === 'function' ?\n            $canvas.getContext('2d', props.contextAttributes) :\n            null;\n\n    $canvas.width = props.width;\n    $canvas.height = props.height;\n\n    return { ctx, $canvas };\n};\n\nexport const stroke = (props: IStrokeProps, ctx: CanvasRenderingContext2D) => {\n    setContextProps([\n        ['lineWidth', props.lineWidth],\n        ['strokeStyle', props.strokeStyle],\n        ['lineCap', props.lineCap],\n        ['lineJoin', props.lineJoin],\n        ['miterLimit', props.miterLimit],\n        ['lineDashOffset', props.lineDashOffset],\n    ],ctx);\n\n    if(props.lineDashSegments){\n        ctx.setLineDash(props.lineDashSegments);\n    }\n};\n\nexport const fill = (props: IFillProps, ctx: CanvasRenderingContext2D) => {\n\n    if(props.fillStyle !== undefined){\n        ctx.fillStyle = props.fillStyle;\n    }\n\n    setContextProps([\n        ['shadowOffsetX', props.shadowOffsetX],\n        ['shadowOffsetY', props.shadowOffsetY],\n        ['shadowBlur', props.shadowBlur],\n        ['shadowColor', props.shadowColor],\n    ],ctx);\n};", "import { fill, stroke } from '../canvas';\nimport {\n    IPolynomialProps,\n    IRectProps,\n    ICircleProps,\n    ILineProps,\n} from '../../interfaces';\n\n/**\n * Draw a line.\n */\nexport const line = (props: ILineProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    ctx.save();\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a line, and optionally draw it.\n */\nexport const linePath = (props: ILineProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    const path = new Path2D();\n\n    path.moveTo(x1, y1);\n    path.lineTo(x2, y2);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a rectangle, including a rectangle with rounded corners.\n * Can also \"clear\" a rectangular space.\n */\nexport const rect = (props: IRectProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x, y, w, h} = props;\n\n    if(props.clear){\n        ctx.clearRect(x, y, w, h);\n        return;\n    }\n\n    if(props.radii){\n        ctx.save();\n\n        fill(props, ctx);\n        stroke(props, ctx);\n\n        ctx.beginPath();\n\n        // @ts-ignore\n        ctx.roundRect(x, y, w, h, props.radii)\n        if(props.fillStyle){\n            ctx.fill();\n        }\n\n        if(props.strokeStyle){\n            ctx.stroke();\n        }\n\n        ctx.restore();\n        return;\n    }\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fillRect(x, y, w, h);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.strokeRect(x, y, w, h);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a rectangle, and optionally draw it.\n */\nexport const rectPath = (props: IRectProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x, y, w, h} = props;\n\n    const path = new Path2D();\n\n    if(props.radii){\n        // @ts-ignore\n        path.roundRect(x, y, w, h, props.radii)\n    }\n    else{\n        path.rect(x, y, w, h);\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomial = (props: IPolynomialProps, ctx: CanvasRenderingContext2D) => {\n\n    const { points } = props;\n\n    ctx.save();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.beginPath();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            ctx.moveTo(point[0], point[1]);\n        }\n        else{\n            ctx.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        ctx.closePath();\n    }\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomialPath = (props: IPolynomialProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { points } = props;\n\n    const path = new Path2D();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            path.moveTo(point[0], point[1]);\n        }\n        else{\n            path.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        path.closePath();\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a circle, or it's segment.\n */\nexport const circle = (props: ICircleProps, ctx: CanvasRenderingContext2D) => {\n    const { cx, cy,r} = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    ctx.save();\n\n    ctx.beginPath();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a circle or its segment, and optionally draw it.\n */\nexport const circlePath = (props: ICircleProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n    const { cx, cy, r } = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    const path = new Path2D();\n\n    path.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n", "import * as canvas from './core/canvas';\nimport * as primitiveShapes from './core/shapes/primitive-shapes';\n\nconst api = {\n    ...canvas,\n    ...primitiveShapes,\n};\n\ndeclare global {\n    interface Window {\n        mzCanvas: typeof api,\n    }\n}\n\nwindow.mzCanvas = window.mzCanvas || api;\n\nexport * from './core/canvas';\nexport * from './core/shapes/primitive-shapes';"],
  "mappings": "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",
  "names": ["canvas_exports", "__export", "canvas", "fill", "setContextProps", "stroke", "setAttributes", "$canvas", "attributes", "attr", "value", "key", "props", "ctx", "prop", "primitive_shapes_exports", "__export", "circle", "circlePath", "line", "linePath", "polynomial", "polynomialPath", "rect", "rectPath", "line", "props", "ctx", "x1", "y1", "x2", "y2", "stroke", "linePath", "path", "rect", "x", "y", "w", "h", "fill", "rectPath", "polynomial", "points", "point", "polynomialPath", "i", "circle", "cx", "cy", "r", "startAngleRad", "endAngleRad", "circlePath", "api", "__spreadValues", "canvas_exports", "primitive_shapes_exports"]
}
